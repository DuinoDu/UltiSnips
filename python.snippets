snippet tool
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
python ${1:yourFunction}.py ${2:args}
'''
import os, sys

def $1(argv):
	${3:pass}

def main():
    import sys
	if len(sys.argv) != 2:
		print(__doc__)
		return
    $1(sys.argv)

if __name__ == "__main__":
	main()
endsnippet

snippet isdir
if not os.path.exists(${1:dirname}):
    os.makedirs($1)
endsnippet

snippet sh
(status, output) = commands.getstatusoutput('$1')
output = output.split('\n')
endsnippet

snippet printi
    sys.stdout.flush()
    sys.stdout.write('writing {}/{}\r'.format(i, len(files)))
    i += 1 # set i = 0 before looping
print '\nFinish!'
endsnippet

snippet prop
@property
def ${1:name}(self):
    return self._$1
endsnippet

snippet camera
cap = cv2.VideoCapture(0)
while True:
    ok, f = cap.read()
    if ok:    
        cv2.imshow("image", f)
    if cv2.waitKey(20) == 27:
        break
cv2.destroyAllWindows()
endsnippet

snippet exit
ch = cv2.waitKey(0) && 0xff
if ch == ord('q'): #27
	break
endsnippet

# mxnet
snippet conv
conv${1:1} = mx.symbol.Convolution(
    data=${2}, num_filter=${3:96}, kernel=(${4:7}, $4), pad=(${5:3},$5), stride=(${6:2}, $6))
relu$1 = mx.symbol.Activation(data=conv$1, act_type="relu")
endsnippet
snippet pool
pool${1:1} = mx.symbol.Pooling(data=${2}, pool_type="max", kernel=(${3:3}, $3), stride=(${4:2},$4))
endsnippet
snippet lrn
lrn${1:1} = mx.symbol.LRN(data=${2}, nsize=3, alpha=0.0005, beta=0.75, knorm=1)
endsnippet

# tensorflow
snippet place
tf.placeholder(tf.float32, [${1}])
endsnippet
snippet var
tf.Variable(${1})
endsnippet
snippet conv
${1} = tf.nn.conv2d(x, W, strides=[1, ${2:stride}, $2, 1], padding='SAME')
endsnippet
snippet pool
${1} = tf.nn.max_pool(x, ksize=[1, ${2:size}, $2, 1], strides=[1,$2, $2, 1], padding='SAME')
endsnippet
snippet bias
tf.nn.bias_add(${1})
endsnippet
snippet relu
tf.nn.relu(${1})
endsnippet
snippet drop
tf.nn.dropout(${1}, dropout)
endsnippet
snippet cross
tf.nn.softmax_cross_entropy_with_logits(${1:model_y}, ${2:y})
endsnippet
snippet add
tf.add(${1})
endsnippet
snippet mul
tf.matmul(${1})
endsnippet
snippet rand
tf.random_normal([${1:h}, ${2:w}, ${3:in}, ${4:out}])
endsnippet
snippet mean
tf.reduce_mean(${1})
endsnippet
snippet cast
tf.cast(${1}, ${2:tf.float32})
endsnippet
snippet equal
tf.equal(${1})
endsnippet
snippet argmax
tf.argmax(${1}, ${2:dimension})
endsnippet

snippet grad
tf.train.GradientDescentOptimizer(learning_rate=${1:learning_rate}).minimize(${2:cost_op})
endsnippet
snippet adam
tf.train.AdamOptimizer(learning_rate=${1:learning_rate}).minimize(${2:cost_op})
endsnippet
snippet train

endsnippet
snippet runtrain
sess.run(train_op, feed_dict = {${1:x}:${2}, ${3:y}:${4}})
endsnippet
snippet runcost
sess.run(cost_op, feed_dict = {${1:x}:${2}, ${3:y}:${4}})
endsnippet
snippet runacc
sess.run(accuracy_op, feed_dict = {${1:x}:${2}, ${3:y}:${4}})
endsnippet


# machine learning
snippet ml
import numpy as np
import tensorflow as tf
from sklearn.utils import shuffle

# parameters
learning_rate = 0.05
epoches = 1000
print_period = 10
print_en = True

# data (dsX, dsY)

# data-preprocess

# model

# cost

# optimizer

# train

endsnippet

