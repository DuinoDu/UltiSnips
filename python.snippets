snippet tool
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import print_function
import argparse

def $2(args):
	${3:pass}

def main(args):
    $2(args)

if __name__ == "__main__":
	parser = argparse.ArgumentParser(description='${1:description of this script}')
	# addarg here
	
	args = parser.parse_args()
	main(args)
endsnippet


snippet isdir
if not os.path.exists(${1:dirname}):
    os.makedirs($1)
endsnippet

snippet dump
with open('${2:file}', 'w') as fid:
	pickle.dump(${1:var}, fid)
endsnippet
snippet load
with open('${1:file}', 'r') as fid:
	${2:var} = pickle.load(fid)
endsnippet

snippet readxml
#import xml.etree.ElementTree as ET
tree = ET.parse(xmlfile)
width = int(tree.find('size').find('width').text)
height = int(tree.find('size').find('height').text)
objs = tree.findall('object')
for index, obj in enumerate(objs):
    name = obj.find('name').text.lower()
    bbox = obj.find('bndbox')
    x1 = int(bbox.find('xmin').text) - 1
    y1 = int(bbox.find('ymin').text) - 1
    x2 = int(bbox.find('xmax').text) - 1
    y2 = int(bbox.find('ymax').text) - 1
endsnippet

snippet sh
cmd = '$1'
(status, output) = commands.getstatusoutput(cmd)
output = output.split('\n')
endsnippet

snippet getimg
${1:imgfiles} = sorted([os.path.join(${2:root}, x) for x in sorted(os.listdir($2)) if x.endswith('.jpg')])
endsnippet

snippet printi
    sys.stdout.flush()
    sys.stdout.write('writing {}/{}\r'.format(i, len(files)))
    i += 1 # set i = 0 before looping
print '\nFinish!'
endsnippet

snippet print
print($1)
endsnippet

snippet printcolor "print colorful string" b
from colorama import Fore, Style
print( Fore.RED+'some red text' + Style.RESET_ALL )
endsnippet

snippet printtable "print table on terminal" b
from prettytable import PrettyTable
table = PrettyTable(['${1:name1}', '${2:name2}'])
table.add_row([${3:name1_value}, ${4:name2_value}])
table.sort_key($2)
table.reversesort = True
print(table)
endsnippet

snippet progress
import tqdm
t = tqdm.tqdm()
t.total = ${1:length}
for i in range($1):
    t.update()
    time.sleep(1)
endsnippet


snippet prop
@property
def ${1:name}(self):
    return self._$1
endsnippet

snippet camera
cap = cv2.VideoCapture(0)
while True:
    ok, f = cap.read()
    if ok:    
        cv2.imshow("image", f)
    if cv2.waitKey(20) == 27:
        break
cv2.destroyAllWindows()
endsnippet

snippet esc
ch = cv2.waitKey(0) & 0xff
if ch == 27: #ord('q')
	break
endsnippet

snippet cv2rect
cv2.rectangle(${1:img}, (${2:x1}, ${3:y1}), (${4:x2}, ${5:y2}), (0, 255, 0), 2)
endsnippet
snippet cv2circle
cv2.circle(${1:img}, (${2:x0}, ${3:y0}), ${4:r}, (0, 255, 0), 2)
endsnippet
snippet cv2resize
cv2.resize(${1:img}, (int($1.shape[1]/${2}), int($1.shape[0]/$2)))
endsnippet

snippet contour
im = cv2.imread(${1:imgpath})
im_gray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)
_, im_thresh = cv2.threshold(im_gray, 177, 255, cv2.THRESH_BINARY)
_, contours, hierarchy = cv2.findContours(im_thresh, cv2.RETR_TREE ,cv2.CHAIN_APPROX_SIMPLE)
cv2.drawContours(im, contours,-1,(0,255,0),1)
endsnippet


#########
# mxnet #
#########
snippet conv
conv${1:1} = mx.symbol.Convolution(
    data=${2}, num_filter=${3:96}, kernel=(${4:7}, $4), pad=(${5:3},$5), stride=(${6:2}, $6))
relu$1 = mx.symbol.Activation(data=conv$1, act_type="relu")
endsnippet
snippet pool
pool${1:1} = mx.symbol.Pooling(data=${2}, pool_type="max", kernel=(${3:3}, $3), stride=(${4:2},$4))
endsnippet
snippet lrn
lrn${1:1} = mx.symbol.LRN(data=${2}, nsize=3, alpha=0.0005, beta=0.75, knorm=1)
endsnippet

##############
# tensorflow #
##############
snippet place
tf.placeholder(tf.float32, shape=[${1}], name='${2}')
endsnippet
snippet var
tf.Variable(${1})
endsnippet
snippet conv
${1} = tf.nn.conv2d(x, W, strides=[1, ${2:stride}, $2, 1], padding='SAME')
endsnippet
snippet pool
${1} = tf.nn.max_pool(x, ksize=[1, ${2:size}, $2, 1], strides=[1,$2, $2, 1], padding='SAME')
endsnippet
snippet bias
tf.nn.bias_add(${1})
endsnippet
snippet relu
tf.nn.relu(${1})
endsnippet
snippet drop
tf.nn.dropout(${1}, dropout)
endsnippet
snippet cross
tf.nn.softmax_cross_entropy_with_logits(${1:model_y}, ${2:y})
endsnippet
snippet add
tf.add(${1})
endsnippet
snippet mul
tf.matmul(${1})
endsnippet
snippet rand
tf.random_normal([${1:h}, ${2:w}, ${3:in}, ${4:out}])
endsnippet
snippet mean
tf.reduce_mean(${1})
endsnippet
snippet cast
tf.cast(${1}, ${2:tf.float32})
endsnippet
snippet equal
tf.equal(${1})
endsnippet
snippet argmax
tf.argmax(${1}, ${2:dimension})
endsnippet
snippet opti
tf.train.GradientDescentOptimizer(learning_rate=${1:learning_rate}).minimize(${2:cost_op})
endsnippet
snippet opti
tf.train.AdamOptimizer(learning_rate=${1:learning_rate}).minimize(${2:cost_op})
endsnippet
snippet runtrain
sess.run(train_op, feed_dict = {${1:x}:${2}, ${3:y}:${4}})
endsnippet
snippet runcost
sess.run(cost_op, feed_dict = {${1:x}:${2}, ${3:y}:${4}})
endsnippet
snippet runacc
sess.run(accuracy_op, feed_dict = {${1:x}:${2}, ${3:y}:${4}})
endsnippet
snippet gpusize
config = tf.ConfigProto()
config.gpu_options.per_process_gpu_memory_fraction = ${1:0.5}
#with tf.Session(config=config) as sess:
endsnippet




snippet train
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import numpy as np

# parameters


# data (dsX, dsY)


# model


# cost


# optimizer


# summary


# train


# evaluate

endsnippet


snippet tic
t1 = time.time()
${1:add your function}
t2 = time.time()    
print "${2:msg to display}: {}".format(t2-t1)
endsnippet


snippet pp
ncpus = 12
ppservers = ()
job_server = pp.Server(ncpus, ppservers=ppservers)

inputs = []
def ${1:foo_work}(${2:arg}):
	# add yor for-loop here 

start_time = time.time()
print("Starting pp with", job_server.get_ncpus(), "workers")
jobs = [(input, job_server.submit($1, (input,)) for input in inputs]
for job in jobs():
	job()
print "Time elapsed: ", time.time() - start_time, "s"

job_server.print_stats()
endsnippet


snippet inctorch
import torch
import torch.nn as nn
import torch.optim as optim
import torch.backends.cudnn as cudnn
import torch.nn.init as init
from torch.autograd import Variable
import torch.utils.data as data
endsnippet

snippet initarg
import argparse
parser = argparse.ArgumentParser(description='${1:description of this script}')
# addarg here

args = parser.parse_args()
endsnippet

snippet addarg
parser.add_argument('--${1:name}', default=${2}, type=${3:str}, help='${4:description}')
endsnippet

snippet addarg_opti
parser.add_argument('--lr', '--learning-rate', default=1e-3, type=float, help='initial learning rate')
parser.add_argument('--momentum', default=0.9, type=float, help='momentum')
parser.add_argument('--weight_decay', default=5e-4, type=float, help='Weight decay for SGD')
parser.add_argument('--gamma', default=0.1, type=float, help='Gamma update for SGD')
endsnippet

snippet setgpu
parser.add_argument('--gpuID', default=0, type=int, help='Use which gpu to train model')
import os
os.environ['CUDA_VISIBLE_DIVICES'] = str(args.gpuID)
endsnippet

snippet model
import torch
import torch.nn as nn
import torch.nn.init as init

class ${1:name}(nn.Module):

    def __init__(self):
        super($1, self).__init__()
        # TODO: design model

    def forward(self, x):
        # TODO: build model
        return x

    def init_weight(self, weight_file=None):
        pass

if __name__ == "__main__":
    # TODO: test model
    pass
endsnippet

snippet testnet
if __name__ == "__main__":
    from torch.autograd import Variable
    net = ${1:Model}(2)
    x = Variable(torch.randn(1,3,1000,800))
    pred = net(x)
    print(pred.size())

    import IPython
    IPython.embed()
endsnippet

snippet summary
parser.add_argument('--tensorboard', default=1, type=int, help='Use tensorboard for loss visualization')
if args.tensorboard:
   from tensorboard import SummaryWriter
   writer = SummaryWriter()
if args.tensorboard:
Â¦   writer.add_scalar('${1:train_loss/cls}', ${2:loss.data[0]}, ${3:iteration})
endsnippet

snippet ask
import six
if six.PY3:
    str_compat = str
else:
    str_compat = unicode
def ask(question, answer=str_compat, default=None, l=None):
    def _input_compat(prompt):
        if six.PY3:
            return input(prompt) 
        else:
            return raw_input(prompt)

    if answer == str_compat:
        r = ''
        while True:
            if default:
                r = _input_compat('> {0} [{1}] '.format(question, default))
            else:
                r = _input_compat('> {0} '.format(question, default))

            r = r.strip()

            if len(r) <= 0:
                if default:
                    r = default
                    break
                else:
                    print('You must enter something')
            else:
                if l and len(r) != l:
                    print('You must enter a {0} letters long string'.format(l))
                else:
                    break
        return r
    elif answer == bool:
        r = None
        while True:
            if default is True:
                r = _input_compat('> {0} (Y/n) '.format(question))
            elif default is False:
                r = _input_compat('> {0} (y/N) '.format(question))
            else:
                r = _input_compat('> {0} (y/n) '.format(question))

            r = r.strip().lower()

            if r in ('y', 'yes'):
                r = True
                break
            elif r in ('n', 'no'):
                r = False
                break
            elif not r:
                r = default
                break
            else:
                print("You must answer 'yes' or 'no'")
        return r
    elif answer == int:
        r = None
        while True:
            if default:
                r = _input_compat('> {0} [{1}] '.format(question, default))
            else:
                r = _input_compat('> {0} '.format(question))

            r = r.strip()

            if not r:
                r = default
                break

            try:
                r = int(r)
                break
            except:
                print('You must enter an integer')
        return r
    else:
        raise NotImplemented(
            'Argument  must be str_compat, bool, or integer')

# Usage:
# value = ask('question?', str_compat, 'default')
# value = ask('question?', int, 0)
# value = ask('question?', bool, default)
endsnippet
